tableDateConverter.ts
import { parseGregorian, formatJalali, isPersianDate, persianToGregorian } from "./dateUtils";
import { LOG_PREFIX, TIME_THRESHOLD_MS, SELECTOR_TABLE_DATES, DATASET_KEYS, PERSIAN_MONTHS, STORAGE_KEYS } from "./constant";

const jalaali = require('jalaali-js');

let dateConversionErrorCount = 0;
let isProcessingDateChanges = false;
let lastDateConversionTime = 0;

function formatJalaliVerbose(date: Date): string {
    const j = jalaali.toJalaali(date);
    return `${PERSIAN_MONTHS[j.jm - 1]} ${j.jd}، ${j.jy}`;
}

function toPersianDigits(input: string): string {
    return input.replace(/\d/g, d => "۰۱۲۳۴۵۶۷۸۹"[parseInt(d)]);
}

async function applyPersianNumbersIfEnabled(text: string): Promise<string> {
    return new Promise((resolve) => {
        chrome.storage.sync.get([STORAGE_KEYS.PERSIAN_NUMBERS], (data) => {
            resolve(data[STORAGE_KEYS.PERSIAN_NUMBERS] ? toPersianDigits(text) : text);
        });
    });
}

export async function convertTableDates(persianInput: boolean): Promise<number> {
    const startTime = Date.now();
    console.log(`${LOG_PREFIX} Starting table date conversion, persianInput =`, persianInput);
    isProcessingDateChanges = true;
    let convertedDateCount = 0;

    try {
        const elements = document.querySelectorAll<HTMLElement>(SELECTOR_TABLE_DATES);
        for (const el of elements) {
            if (!isElementVisible(el)) continue;

            const currentText = el.innerText.trim();
            if (!currentText) continue;

            const [startDateText, endDateText] = currentText.split('→').map(s => s.trim());

            if (persianInput) {
                if (isPersianDate(startDateText)) continue;

                const startDate = parseGregorian(startDateText);
                const endDate = endDateText ? parseGregorian(endDateText) : null;

                if (startDate) {
                    const jalaliStart = /[a-zA-Z]/.test(startDateText) ? formatJalaliVerbose(startDate) : formatJalali(startDate);
                    const jalaliEnd = endDate ? (/[a-zA-Z]/.test(endDateText) ? formatJalaliVerbose(endDate) : formatJalali(endDate)) : null;
                    if (jalaliStart === "Invalid Date" || (endDate && jalaliEnd === "Invalid Date")) continue;

                    const jalaliRange = jalaliEnd ? `${jalaliStart} → ${jalaliEnd}` : jalaliStart;
                    const finalText = await applyPersianNumbersIfEnabled(jalaliRange);

                    if (el.innerText !== finalText) {
                        if (!el.hasAttribute(DATASET_KEYS.ORIGINAL_DATE)) {
                            el.setAttribute(DATASET_KEYS.ORIGINAL_DATE, currentText);
                        }
                        el.innerText = finalText;
                        convertedDateCount++;
                        console.log(`${LOG_PREFIX} Converted`, currentText, "to", finalText);
                    }
                }
            } else {
                if (isPersianDate(startDateText) || el.hasAttribute(DATASET_KEYS.ORIGINAL_DATE)) {
                    const originalDate = el.getAttribute(DATASET_KEYS.ORIGINAL_DATE);
                    if (originalDate) {
                        el.innerText = originalDate;
                        el.removeAttribute(DATASET_KEYS.ORIGINAL_DATE);
                        convertedDateCount++;
                        console.log(`${LOG_PREFIX} Restored original date:`, originalDate);
                    } else {
                        const gregorianStart = persianToGregorian(startDateText);
                        const gregorianEnd = endDateText ? persianToGregorian(endDateText) : null;
                        if (gregorianStart) {
                            const gregorianRange = gregorianEnd ? `${gregorianStart} ← ${gregorianEnd}` : gregorianStart;
                            const finalText = await applyPersianNumbersIfEnabled(gregorianRange);
                            el.innerText = finalText;
                            convertedDateCount++;
                            console.log(`${LOG_PREFIX} Converted Persian to Gregorian:`, currentText, "->", finalText);
                        }
                    }
                }
            }
        }

        lastDateConversionTime = startTime;
        console.log(`${LOG_PREFIX} Processed ${convertedDateCount} dates`);
    } catch (error) {
        console.error("Error during conversion:", error);
        dateConversionErrorCount++;
    } finally {
        isProcessingDateChanges = false;
    }

    return convertedDateCount;
}


function isElementVisible(element: HTMLElement): boolean {
    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
}

export async function resetAllConversions(): Promise<number> {
    console.log(`${LOG_PREFIX} Resetting all conversions`);
    isProcessingDateChanges = true;
    let resetDateCount = 0;

    try {
        dateConversionErrorCount = 0;

        document.querySelectorAll<HTMLElement>(`[${DATASET_KEYS.ORIGINAL_DATE}]`).forEach(el => {
            const originalDate = el.getAttribute(DATASET_KEYS.ORIGINAL_DATE);
            if (originalDate) {
                el.innerText = originalDate;
                el.removeAttribute(DATASET_KEYS.ORIGINAL_DATE);
                resetDateCount++;
                console.log(`${LOG_PREFIX} Reset to original date:`, originalDate);
            }
        });

        const elements = document.querySelectorAll<HTMLElement>(SELECTOR_TABLE_DATES);
        for (const el of elements) {
            if (!isElementVisible(el)) continue;

            const currentText = el.innerText.trim();
            if (!currentText || !isPersianDate(currentText) || el.hasAttribute(DATASET_KEYS.ORIGINAL_DATE)) continue;

            const [startDateText, endDateText] = currentText.split('→').map(s => s.trim());
            const gregorianStart = persianToGregorian(startDateText);
            const gregorianEnd = endDateText ? persianToGregorian(endDateText) : null;

            if (gregorianStart) {
                const gregorianRange = gregorianEnd ? `${gregorianStart} → ${gregorianEnd}` : gregorianStart;
                const finalText = await applyPersianNumbersIfEnabled(gregorianRange);
                el.innerText = finalText;
                resetDateCount++;
                console.log(`${LOG_PREFIX} Converted Persian to Gregorian:`, currentText, "->", finalText);
            }
        }

        console.log(`${LOG_PREFIX} Reset ${resetDateCount} date cells`);
    } finally {
        isProcessingDateChanges = false;
    }

    return resetDateCount;
}

export function wasDateConversionRecent(timeThresholdMs = TIME_THRESHOLD_MS): boolean {
    return (Date.now() - lastDateConversionTime) < timeThresholdMs;
}

export function isDateConversionInProgress(): boolean {
    return isProcessingDateChanges;
}

export function getErrorCount(): number {
    return dateConversionErrorCount;
}

+++++
convertCalendar.ts
import jalaali from 'jalaali-js';
import { PERSIAN_MONTHS, SYSTEM_FONTS, STORAGE_KEYS, DEFAULT_FONT } from "./constant";

const MONTHS: Record<string, number> = {
  January: 1, February: 2, March: 3, April: 4, May: 5, June: 6,
  July: 7, August: 8, September: 9, October: 10, November: 11, December: 12
};

// Keep the original mapping for lookup
const persianDayNamesLookup: Record<string, string> = {
  Sat: "شنبه",
  Sun: "یکشنبه",
  Mon: "دوشنبه",
  Tue: "سه‌شنبه",
  Wed: "چهارشنبه",
  Thu: "پنج‌شنبه",
  Fri: "جمعه"
};

function toPersianDigits(input: string): string {
  return input.replace(/\d/g, d => "۰۱۲۳۴۵۶۷۸۹"[parseInt(d)]);
}

let currentFont = DEFAULT_FONT;

// Big Calendar
function convertCalendarHeader(): void {
  const smallHeaderEl = document.querySelector('.sc-1htxemp-6.jsehgZ');
  const bigHeaderEl = document.querySelector('.sc-vb7gpf-1.jIHpro');
  if (!smallHeaderEl || !bigHeaderEl) return;
  const text = smallHeaderEl.textContent?.trim();
  if (!text) return;
  bigHeaderEl.textContent = text;
  bigHeaderEl.setAttribute('dir', 'rtl');
  (bigHeaderEl as HTMLElement).style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
}

function convertCalendarDays(): void {
    const containers = document.querySelectorAll('[data-grid-date]');
    containers.forEach(container => {
      const tsStr = container.getAttribute('data-grid-date');
      if (!tsStr) return;
      const baseDate = new Date(parseInt(tsStr));
      const dayButtons = container.querySelectorAll('.sc-12m9yy-5');
      dayButtons.forEach((btn, index) => {
        const cellDate = new Date(baseDate);
        cellDate.setDate(cellDate.getDate() + index);
        const jDate = jalaali.toJalaali(cellDate);
        const dayText = toPersianDigits(jDate.jd.toString());

        // If it's the 1st day of the month, show month and year
        if (jDate.jd === 1) {
          const persianMonth = PERSIAN_MONTHS[jDate.jm - 1];
          const persianYear = toPersianDigits(jDate.jy.toString());
          let strong = btn.querySelector('strong');
          if (!strong) {
            strong = document.createElement('strong');
            // Prepend strong to keep month before day number visually
            btn.insertBefore(strong, btn.firstChild);
          }
          // Add spaces for visual separation if needed
          strong.textContent = ` ${persianMonth} `;
          (strong as HTMLElement).style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
          (strong as HTMLElement).style.direction = 'rtl'; // Keep month name RTL
        } else {
          // Remove month element if exists from previous renders
          const strong = btn.querySelector('strong');
          if (strong) {
            strong.textContent = ''; // Clear content instead of removing element
          }
        }

        // Set day number
        const span = btn.querySelector('span');
        if (span) {
          // Ensure the span only contains the day number
          // Remove any child nodes (like old strong tags if they somehow got nested)
          while(span.firstChild) {
              span.removeChild(span.firstChild);
          }
          span.textContent = dayText; // Set the day number
          (span as HTMLElement).style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
          (span as HTMLElement).style.direction = 'rtl'; // Keep day number RTL
        }
         // Ensure the button itself flows RTL if needed, though individual elements handle it
        (btn as HTMLElement).style.direction = 'rtl';
      });
    });
}


function convertBigCalendar(): void {
  convertCalendarHeader();
  convertCalendarDays();
  // NOTE: Day name reversal happens in reverseAndConvertDayNames, called by convertCalendar
}

// Small Calendar
function convertSmallCalendarHeader(): void {
  // Reuse the big calendar header logic if the selectors are the same or similar
  // If the small calendar header needs specific logic, implement it here.
  // Assuming it uses '.sc-1htxemp-6.jsehgZ' like the original code:
  const headerEl = document.querySelector('.sc-1htxemp-6.jsehgZ');
  if (!headerEl) return;

  // Get Gregorian month/year text (e.g., "April 2025")
  // This might need adjustment if the text format changes
  const text = headerEl.textContent?.trim();
  if (!text) return;

  const parts = text.split(/\s+/);
  if (parts.length < 2) return; // Expecting "Month Year"

  const monthName = parts[0];
  const yearStr = parts.slice(1).join(' '); // Handle potential spaces in month names if any
  const year = parseInt(yearStr);

  const monthNum = MONTHS[monthName];

  if (!monthNum || isNaN(year)) {
      console.warn("Could not parse small calendar header:", text);
      return; // Exit if month or year is invalid
  }

  // Use the first day of the Gregorian month to find the corresponding Jalaali month/year
  const gregDate = new Date(year, monthNum - 1, 1);
  const jDate = jalaali.toJalaali(gregDate);

  const persianMonth = PERSIAN_MONTHS[jDate.jm - 1];
  const persianYear = toPersianDigits(jDate.jy.toString());

  headerEl.textContent = `${persianMonth} ${persianYear}`;
  headerEl.setAttribute('dir', 'rtl');
  (headerEl as HTMLElement).style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
}


function convertSmallCalendarDays(): void {
  // Assuming small calendar uses '.rdp-month_grid td' and '.sc-1htxemp-12.gMCvNC'
  const dayEls = document.querySelectorAll('.rdp-month_grid td');
  dayEls.forEach(td => {
    const dayStr = td.getAttribute('data-day'); // Expecting ISO date string like "2025-04-01T00:00:00.000Z"
    if (!dayStr) return;

    try {
        const dateObj = new Date(dayStr);
        if (isNaN(dateObj.getTime())) {
            console.warn("Invalid date string for small calendar day:", dayStr);
            return;
        }
        const jDate = jalaali.toJalaali(dateObj);

        const btn = td.querySelector('button'); // Or the direct element holding the day number
        if (!btn) return;

        // Find the specific div/span holding the day number
        const dayDiv = btn.querySelector('.sc-1htxemp-12.gMCvNC'); // Adjust selector if needed
        if (!dayDiv) return;

        dayDiv.textContent = toPersianDigits(jDate.jd.toString());
        (dayDiv as HTMLElement).style.direction = 'rtl'; // Or set on parent if better
        (dayDiv as HTMLElement).style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;

    } catch (e) {
        console.error("Error processing small calendar day:", dayStr, e);
    }
  });
}


function convertSmallCalendar(): void {
  convertSmallCalendarHeader();
  convertSmallCalendarDays();
   // NOTE: Day name reversal (if applicable to small calendar) happens in reverseAndConvertDayNames
}

// *** NEW FUNCTION ***
function reverseAndConvertDayNames(): void {
  // Select the container holding the day names for the BIG calendar
  const container = document.querySelector('.sc-lmxfee-3.iRQjYM');
  if (!container) {
      console.log("Day name container not found.");
      return;
  }

  // Select only the actual day name elements (excluding the 'W' placeholder)
  const dayNameEls = container.querySelectorAll('.sc-1rt47i1-0.sc-lmxfee-0.habFrR');
  if (dayNameEls.length === 0) {
      console.log("Day name elements not found.");
      return;
  }

  // Convert NodeList to Array and reverse it
  const reversedDayNameEls = Array.from(dayNameEls).reverse();

  // Process and re-append elements in reversed order
  reversedDayNameEls.forEach(el => {
    const original = el.textContent?.trim();
    if (original && persianDayNamesLookup[original]) {
      el.textContent = persianDayNamesLookup[original]; // Translate
      (el as HTMLElement).setAttribute('dir', 'rtl');
      (el as HTMLElement).style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
    } else {
        console.warn("Could not translate day name:", original);
    }
    // Append the element back to the container. This moves it to the end.
    // Since we iterate through the *reversed* list, they end up in the desired reversed order.
    container.appendChild(el);
  });

   // --- Optional: Handle Small Calendar Day Names ---
   // If the small calendar has *different* day name elements that also need reversing,
   // add similar logic here targeting its specific container and day elements.
   // Example (replace selectors):
   /*
   const smallCalContainer = document.querySelector('.small-calendar-day-names-container');
   if (smallCalContainer) {
       const smallCalDayEls = smallCalContainer.querySelectorAll('.small-cal-day-name');
       if (smallCalDayEls.length > 0) {
           const reversedSmallCalDayEls = Array.from(smallCalDayEls).reverse();
           reversedSmallCalDayEls.forEach(el => {
               // ... translate and style ...
               smallCalContainer.appendChild(el);
           });
       }
   }
   */
}


export function convertCalendar(): void {
  // Run conversions
  convertBigCalendar(); // Handles big calendar header and day numbers
  convertSmallCalendar(); // Handles small calendar header and day numbers
  reverseAndConvertDayNames(); // Reverses and converts day names (primarily for big calendar)
}

function setupObserver(selector: string, callback: () => void): void {
  const container = document.querySelector(selector);
  if (!container) {
    console.warn("Observer target not found:", selector);
    return;
  }
  const observer = new MutationObserver((mutationsList) => {
      // Optional: debounce or check mutations if performance is an issue
      callback();
  });
  observer.observe(container, { childList: true, subtree: true, characterData: true }); // Observe changes
}

// Listen for storage changes
chrome.storage.onChanged.addListener((changes, area) => {
  if (area === 'sync' && (changes[STORAGE_KEYS.PERSIAN_INPUT] || changes[STORAGE_KEYS.SELECTED_FONT])) {
    chrome.storage.sync.get([STORAGE_KEYS.PERSIAN_INPUT, STORAGE_KEYS.SELECTED_FONT], data => {
      const persianInput = data[STORAGE_KEYS.PERSIAN_INPUT];
      currentFont = data[STORAGE_KEYS.SELECTED_FONT] || DEFAULT_FONT;
      if (persianInput) {
          console.log("Storage change detected, running convertCalendar.");
          convertCalendar(); // Rerun all conversions
      }
      // Optional: Add logic here to *revert* changes if persianInput becomes false
    });
  }
});

// Init based on popup settings
chrome.storage.sync.get([STORAGE_KEYS.PERSIAN_INPUT, STORAGE_KEYS.SELECTED_FONT], data => {
  const persianInput = data[STORAGE_KEYS.PERSIAN_INPUT];
  currentFont = data[STORAGE_KEYS.SELECTED_FONT] || DEFAULT_FONT;

  if (persianInput) {
    console.log("Initial load with Persian enabled, running convertCalendar.");
    // Initial conversion
    convertCalendar();

    // --- Setup Observers ---
    // Observer for the main calendar container (for month changes, etc.)
    // The specific class '.sc-1kdlpav-16.hUCMDN' seems to wrap the grid
    setupObserver('.sc-1kdlpav-16.hUCMDN', () => {
        console.log("Big calendar container mutation detected.");
        convertCalendar(); // Rerun all conversions
    });

    // Observer for the small calendar container (if its updates are separate)
    // The class '.sc-1htxemp-14.hBaYBJ' might be the parent of the small calendar month view
    setupObserver('.sc-1htxemp-14.hBaYBJ', () => {
        console.log("Small calendar container mutation detected.");
        convertCalendar(); // Rerun all conversions
    });

    // Debounced scroll listener (might still be needed if content loads lazily on scroll)
    let timer: number | null = null;
    window.addEventListener('scroll', () => {
      if (timer) clearTimeout(timer);
      timer = window.setTimeout(() => {
          // Check if conversion is still enabled before running
          chrome.storage.sync.get([STORAGE_KEYS.PERSIAN_INPUT], currentData => {
             if (currentData[STORAGE_KEYS.PERSIAN_INPUT]) {
                 console.log("Scroll timeout, running convertCalendar.");
                 convertCalendar();
             }
          });
      }, 300); // 300ms debounce
    }, { passive: true }); // Use passive listener for better scroll performance

  } else {
      console.log("Initial load with Persian disabled.");
      // Optional: Add logic here to ensure the calendar is in its default state
  }
});

// --- Ensure constants are defined ---
// These should be in your './constant' file or defined here if not importing
/*
export const PERSIAN_MONTHS = ["فروردین", "اردیبهشت", "خرداد", "تیر", "مرداد", "شهریور", "مهر", "آبان", "آذر", "دی", "بهمن", "اسفند"];
export const SYSTEM_FONTS = "Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif"; // Example
export const STORAGE_KEYS = {
    PERSIAN_INPUT: 'persianInputEnabled', // Example key name
    SELECTED_FONT: 'selectedPersianFont' // Example key name
};
export const DEFAULT_FONT = "Tahoma"; // Example default
*/
+++++
constant.ts
// Logging
export const LOG_PREFIX = "mtlog:";

// Date Utilities
export const MONTHS: Record<string, number> = {
  january: 1, february: 2, march: 3, april: 4, may: 5, june: 6,
  july: 7, august: 8, september: 9, october: 10, november: 11, december: 12,
  jan: 1, feb: 2, mar: 3, apr: 4, jun: 6, jul: 7, aug: 8, sep: 9, sept: 9, oct: 10, nov: 11, dec: 12
};

export const PERSIAN_MONTHS = [
  'فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور',
  'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'
];

export const STANDARD_DATE_FORMAT = /^(\d{4})\/(\d{1,2})\/(\d{1,2})$/;

// Table Date Converter
export const TIME_THRESHOLD_MS = 500;
export const SELECTOR_TABLE_DATES = "[data-testid='property-value'] div, div.notion-date";

// Convert Notifications
export const PANEL_ID = 'persian-dates-panel';
export const CONTENT_ID = 'persian-dates-content';
export const MINIMIZE_BTN_ID = 'persian-dates-minimize';
export const HIDE_BTN_ID = 'persian-dates-hide';
export const SHOW_BTN_ID = 'persian-dates-show-button';
export const TOAST_ID = 'persian-dates-toast';
export const PANEL_TITLE = 'Persian Dates';
export const NO_DATES_MESSAGE = 'No date mentions found.';
export const CLICK_INSTRUCTION = 'Click a date to copy Persian format or scroll to its location';
export const SELECTOR_MENTIONS = '.notion-text-mention-token .notion-reminder';
export const PANEL_STATE_KEY = 'persian-dates-panel-state';

// Font Injection
export const UNICODE_RANGE = 'U+0600-06FF, U+0750-077F, U+FB50-FDFF, U+FE70-FEFF';
export const DEFAULT_FONTS = [
  { en_name: "Vazirmatn", fa_name: "وزیر متن", creator: "صابر راستی کردار" },
  { en_name: "Sahel", fa_name: "ساحل", creator: "صابر راستی کردار" },
  { en_name: "Parastoo", fa_name: "پرستو", creator: "صابر راستی کردار" }
];
export const ALL_FONTS_CSS = `
/* ========== Vazirmatn ========== */
@font-face {
  font-family: "Vazirmatn";
  src:
    url("${chrome.runtime.getURL('assets/fonts/vazir/Vazirmatn[wght].woff2')}")
      format("woff2 supports variations"),
    url("${chrome.runtime.getURL('assets/fonts/vazir/Vazirmatn[wght].woff2')}")
      format("woff2-variations");
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
  unicode-range: ${UNICODE_RANGE};
}

/* ========== Sahel ========== */
@font-face {
  font-family: "Sahel";
  src:
    url("${chrome.runtime.getURL('assets/fonts/sahel/Sahel-VF.woff2')}")
      format("woff2 supports variations"),
    url("${chrome.runtime.getURL('assets/fonts/sahel/Sahel-VF.woff2')}")
      format("woff2-variations");
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
  unicode-range: ${UNICODE_RANGE};
}

/* ========== Parastoo ========== */
@font-face {
  font-family: "Parastoo";
  src: url("${chrome.runtime.getURL('assets/fonts/parastoo/Parastoo.woff2')}") format("woff2");
  font-weight: normal;
  font-style: normal;
  unicode-range: ${UNICODE_RANGE};
}
@font-face {
  font-family: "Parastoo";
  src: url("${chrome.runtime.getURL('assets/fonts/parastoo/Parastoo-Bold.woff2')}")
    format("woff2");
  font-weight: bold;
  font-style: normal;
  unicode-range: ${UNICODE_RANGE};
}

/* Keep code blocks in LTR */
.notion-text-content[data-content-type="code"] {
  direction: ltr !important;
  text-align: left !important;
  font-family: "SF Mono", "Consolas", "Monaco", "Andale Mono", monospace !important;
}
`;
export const SELECTOR_EDITABLE_TEXT = '.notranslate[data-content-editable-leaf="true"]';
export const SELECTOR_CODE_BLOCK = '[data-content-type="code"]';
export const SELECTOR_NUMBERED_LIST = '.notion-selectable.notion-numbered_list-block';
export const SELECTOR_QUOTE_BLOCK = '.notion-quote-block';
export const SELECTOR_TOGGLE_BLOCK = '.notion-selectable.notion-toggle-block';
export const SELECTOR_BULLETED_LIST = '.notion-selectable.notion-bulleted_list-block';
export const SELECTOR_TABLE_BLOCK = '.notion-table-block';
export const SELECTOR_TODO_BLOCK = '.notion-to_do-block';
export const SELECTOR_RTL_ELEMENTS = '.notion-body h1, .notion-body h2, .notion-body h3, .notion-body h4, .notion-body h5, .notion-body h6, ' +
  '.notion-table-view th, .notion-table-view td, .notion-collection_view-block div[data-content-editable-void="true"] > div:nth-child(2), ' +
  '.notion-table-view-header-cell, .notion-table-view-cell';
export const SELECTOR_GLOBAL_FONTS = [
  '.notion-page-content',
  '.notion-table-view',
  '.notion-board-view',
  '.notion-gallery-view',
  '.notion-page-block',
  '.notion-topbar',
  '.notion-body',
  '.notion-selectable',
  '.notion-collection_view-block',
  '.notion-frame',
  '.notion-collection-item'
].join(', ');
export const DEFAULT_FONT = 'Vazirmatn';
export const SYSTEM_FONTS = '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, sans-serif';

// Convert Text
export const DATASET_KEYS = {
  ORIGINAL_DATE: 'originalDate',
  CONVERTED: 'converted'
};
export const SELECTOR_REMINDERS = '.notion-reminder';

// Storage Keys
export const STORAGE_KEYS = {
  PERSIAN_INPUT: 'persianInput',
  FONT_INJECTION_ENABLED: 'fontInjectionEnabled',
  SELECTED_FONT: 'selectedFont',
  PERSIAN_NUMBERS: 'persianNumbers' 
};

// UI Elements
export const UI_ELEMENTS = {
  PERSIAN_TOGGLE: 'persian-toggle',
  FONT_TOGGLE: 'font-toggle',
  RESET_BUTTON: 'reset-button',
  ERROR_MESSAGE: 'error-message',
  FONT_SELECTOR_CONTAINER: 'font-selector-container',
  FONT_SELECTOR: 'font-selector',
  FONT_AUTHOR: 'font-author',
  STATUS: 'status',
  CALL_MESSAGE: 'call-message'
};

// Message Types
export const MESSAGE_TYPES = {
  APPLY_SETTINGS: 'applySettings',
  RESET_COMPLETE: 'resetComplete',
  ERROR_COUNT_CHANGED: 'errorCountChanged',
  CHECK_ERRORS: 'checkErrors',
  REFRESH_CONVERSION: 'refreshConversion'
};

// Content Script
export const DEBOUNCE_DELAY = 300;
export const NOTION_URL_PATTERN = '*://*.notion.so/*';
export const SELECTOR_DATE_BUTTONS = 'button[name="day"]';
export const SELECTOR_PREV_MONTH = 'button[name="previous-month"]';
export const SELECTOR_NEXT_MONTH = 'button[name="next-month"]';
export const SELECTOR_DATE_FORMAT_CLEAR = '[role="button"]';
export const SELECTOR_DATE_MENTION = '.notion-selectable';
export const SELECTOR_PROPERTY_VALUE = '[data-testid="property-value"]';
export const SELECTOR_DATE_PICKER_INPUT = '.rdp';

// Popup HTML
export const HTML_CONSTANTS = {
  TITLE: 'نوشن فارسی',
  HEADER_TEXT: 'نوشن فارسی',
  CALENDAR_LABEL: 'تاریخ شمسی',
  FONT_LABEL: 'فونت فارسی',
  CALL_MESSAGE: 'اگه چیزی خراب بود، یه خبر بهم بده  🐞',
  FOOTER_NAME: 'Matthew Truth'
};
+++++
dateUtils.ts
import { format } from "date-fns-jalali";
import { MONTHS, PERSIAN_MONTHS, STANDARD_DATE_FORMAT } from "./constant";

const jalaali = require('jalaali-js');

export function isPersianDate(text: string): boolean {
  if (!text || typeof text !== 'string') return false;

  text = text.trim();
  const standardFormat = text.match(STANDARD_DATE_FORMAT);
  if (standardFormat) {
    const year = parseInt(standardFormat[1], 10);
    const month = parseInt(standardFormat[2], 10);
    const day = parseInt(standardFormat[3], 10);
    if (year >= 1300 && year < 1500 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
      return jalaali.isValidJalaaliDate(year, month, day);
    }
  }

  return PERSIAN_MONTHS.some(month => text.includes(month));
}

export function parseGregorian(text: string): Date | null {
  if (!text || typeof text !== 'string' || isPersianDate(text)) return null;

  text = text.trim();

  try {
    let m = text.match(/\b([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})\b/);
    if (m) {
      const mon = MONTHS[m[1].toLowerCase()];
      if (!mon) return null;
      return new Date(+m[3], mon - 1, +m[2]);
    }

    m = text.match(/\b(\d{4})[-/](\d{1,2})[-/](\d{1,2})\b/);
    if (m) {
      const year = parseInt(m[1], 10);
      const month = parseInt(m[2], 10);
      const day = parseInt(m[3], 10);

      if (year >= 1300 && year < 1500 && !Object.keys(MONTHS).some(month => text.toLowerCase().includes(month.toLowerCase()))) {
        return null;
      }

      if (month < 1 || month > 12 || day < 1 || day > 31) return null;
      return new Date(year, month - 1, day);
    }

    m = text.match(/\b(\d{1,2})\/(\d{1,2})\/(\d{4})\b/);
    if (m) {
      const month = parseInt(m[1], 10);
      const day = parseInt(m[2], 10);
      const year = parseInt(m[3], 10);

      if (year >= 1300 && year < 1500) return null;
      if (month < 1 || month > 12 || day < 1 || day > 31) return null;
      return new Date(year, month - 1, day);
    }

    m = text.match(/\b(\d{4})\s+([A-Za-z]+)\s+(\d{1,2})\b/);
    if (m) {
      const mon = MONTHS[m[2].toLowerCase()];
      if (!mon) return null;
      return new Date(+m[1], mon - 1, +m[3]);
    }

    if (/today/i.test(text)) return new Date();
    if (/yesterday/i.test(text)) {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      return yesterday;
    }
    if (/tomorrow/i.test(text)) {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      return tomorrow;
    }
  } catch (error) {
    console.error("Error parsing date:", text, error);
  }

  return null;
}

export function formatJalali(d: Date): string {
  if (!d || !(d instanceof Date) || isNaN(d.getTime())) {
    console.error("Invalid date passed to formatJalali", d);
    return "Invalid Date";
  }

  try {
    const jalali = jalaali.toJalaali(d);
    return `${jalali.jy}/${jalali.jm.toString().padStart(2, '0')}/${jalali.jd.toString().padStart(2, '0')}`;
  } catch (error) {
    console.error("Error in formatJalali:", error);
    return "Invalid Date";
  }
}

export function persianToGregorian(persianDateStr: string): string | null {
  try {
    const match = persianDateStr.match(STANDARD_DATE_FORMAT);
    if (!match) return null;

    const jy = parseInt(match[1], 10);
    const jm = parseInt(match[2], 10);
    const jd = parseInt(match[3], 10);

    if (!jalaali.isValidJalaaliDate(jy, jm, jd)) return null;

    const gregorian = jalaali.toGregorian(jy, jm, jd);
    return `${gregorian.gy}/${gregorian.gm.toString().padStart(2, '0')}/${gregorian.gd.toString().padStart(2, '0')}`;
  } catch (error) {
    console.error("Error converting Persian to Gregorian:", error);
    return null;
  }
}
+++++
test.ts
const jalaali = require('jalaali-js');

console.log("TESTING JALAALI CONVERSIONS");
console.log("==========================");

const gregorianDate = new Date(2023, 2, 21);
const jalaliDate = jalaali.toJalaali(gregorianDate);
console.log("Test 1: Gregorian to Jalaali");
console.log("Gregorian:", gregorianDate.toDateString());
console.log("Jalaali:", `${jalaliDate.jy}/${jalaliDate.jm}/${jalaliDate.jd}`);
console.log();

const jy = 1402;
const jm = 1;
const jd = 1;
const gregorian = jalaali.toGregorian(jy, jm, jd);
console.log("Test 2: Jalaali to Gregorian");
console.log("Jalaali:", `${jy}/${jm}/${jd}`);
console.log("Gregorian:", `${gregorian.gy}/${gregorian.gm}/${gregorian.gd}`);
console.log();

const futureDate = new Date(2025, 0, 1);
const futurePersian = jalaali.toJalaali(futureDate);
console.log("Test 3: Future date conversion");
console.log("Gregorian:", futureDate.toDateString());
console.log("Jalaali:", `${futurePersian.jy}/${futurePersian.jm}/${futurePersian.jd}`);
console.log();

const isLeap1403 = jalaali.isLeapJalaaliYear(1403);
const isLeap1404 = jalaali.isLeapJalaaliYear(1404);
console.log("Test 4: Leap year detection");
console.log("Is 1403 a leap year?", isLeap1403);
console.log("Is 1404 a leap year?", isLeap1404);
console.log();

console.log("Test 5: Month lengths");
console.log("Length of month 12 in year 1403:", jalaali.jalaaliMonthLength(1403, 12));
console.log("Length of month 12 in year 1404:", jalaali.jalaaliMonthLength(1404, 12));
+++++
convertTimeline.ts
import jalaali from 'jalaali-js';
import { PERSIAN_MONTHS, SYSTEM_FONTS, STORAGE_KEYS, DEFAULT_FONT } from "./constant";

const MONTHS: Record<string, number> = {
  January: 1, February: 2, March: 3, April: 4, May: 5, June: 6,
  July: 7, August: 8, September: 9, October: 10, November: 11, December: 12
};

function toPersianDigits(input: string): string {
  return input.replace(/\d/g, d => "۰۱۲۳۴۵۶۷۸۹"[parseInt(d)]);
}

let currentFont = DEFAULT_FONT;

function convertTimelineHeader(): void {
  const headerSpan = document.querySelector<HTMLElement>('.notion-timeline-view div[style*="padding-top"] span');
  if (!headerSpan) return;
  const text = headerSpan.textContent?.trim();
  if (!text) return;
  const parts = text.split(' ');
  if (parts.length < 2) return;
  const monthName = parts[0];
  const year = parseInt(parts[1], 10);
  const monthNum = MONTHS[monthName];
  if (!monthNum || isNaN(year)) return;
  const gregDate = new Date(year, monthNum - 1, 1);
  const jDate = jalaali.toJalaali(gregDate);
  const newText = `${PERSIAN_MONTHS[jDate.jm - 1]} ${toPersianDigits(jDate.jy.toString())}`;
  headerSpan.textContent = newText;
  headerSpan.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
  headerSpan.setAttribute('dir', 'rtl');
  (window as any).__timelineBaseDate = gregDate;
}

function convertTimelineDays(): void {
  const baseDate: Date = (window as any).__timelineBaseDate;
  if (!baseDate) return;
  const dayContainer = document.querySelector('.notion-timeline-view .notion-shimmer-timeline-transition');
  if (!dayContainer) return;

  const cells = Array.from(dayContainer.querySelectorAll<HTMLElement>('div[style*="width: 40px"]'));
  cells.forEach((el, index) => {
    const cellDate = new Date(baseDate);
    cellDate.setDate(baseDate.getDate() + index);
    const jDate = jalaali.toJalaali(cellDate);
    const dayText = toPersianDigits(jDate.jd.toString());
    const span = el.querySelector('span');
    if (span) {
      span.textContent = dayText;
      span.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
      span.setAttribute('dir', 'rtl');
    } else {
      el.textContent = dayText;
      el.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
      el.setAttribute('dir', 'rtl');
    }
  });

  const redCircles = dayContainer.querySelectorAll<HTMLElement>('div[style*="background: rgb(211, 79, 67)"]');
  redCircles.forEach(circle => circle.remove());
}

function convertTimelineMonthLabels(): void {
  const container = document.querySelector<HTMLElement>('.notion-timeline-view > div[style*="background: white"][style*="box-shadow: inset"]');
  if (!container) return;
  const baseDate: Date = (window as any).__timelineBaseDate;
  if (!baseDate) return;

  const labels = container.querySelectorAll<HTMLElement>('div');
  labels.forEach(label => {
    const text = label.textContent?.trim();
    if (!text || MONTHS[text] === undefined) return;

    const left = parseFloat(label.style.left || '0');
    const daysFromStart = Math.round(left / 40);
    const cellDate = new Date(baseDate);
    cellDate.setDate(baseDate.getDate() + daysFromStart);
    const jDate = jalaali.toJalaali(cellDate);
    const persianMonth = PERSIAN_MONTHS[jDate.jm - 1];
    label.textContent = persianMonth;
    label.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
    label.setAttribute('dir', 'rtl');
  });
}

export function convertTimeline(): void {
  chrome.storage.sync.get([STORAGE_KEYS.SELECTED_FONT], data => {
    currentFont = data[STORAGE_KEYS.SELECTED_FONT] || DEFAULT_FONT;
    convertTimelineHeader();
    convertTimelineDays();
    convertTimelineMonthLabels();
  });
}

function setupTimelineObserver(): void {
  const el = document.querySelector('.notion-timeline-view');
  if (!el) return;
  const observer = new MutationObserver(() => convertTimeline());
  observer.observe(el, { childList: true, subtree: true, characterData: true });
}

chrome.storage.onChanged.addListener((changes, area) => {
  if (area === 'sync' && changes[STORAGE_KEYS.SELECTED_FONT]) {
    chrome.storage.sync.get([STORAGE_KEYS.SELECTED_FONT], data => {
      currentFont = data[STORAGE_KEYS.SELECTED_FONT] || DEFAULT_FONT;
      convertTimeline();
    });
  }
});

function initTimelineConversion(): void {
  chrome.storage.sync.get([STORAGE_KEYS.SELECTED_FONT], data => {
    currentFont = data[STORAGE_KEYS.SELECTED_FONT] || DEFAULT_FONT;
    if (document.querySelector('.notion-timeline-view')) {
      convertTimeline();
      setupTimelineObserver();
    }
  });
}

setTimeout(initTimelineConversion, 1500);

+++++
convertNotif.ts
const jalaali = require('jalaali-js');
import { parseGregorian, isPersianDate } from "./dateUtils";
import { LOG_PREFIX, PANEL_ID, CONTENT_ID, MINIMIZE_BTN_ID, HIDE_BTN_ID, SHOW_BTN_ID, TOAST_ID, PANEL_TITLE, NO_DATES_MESSAGE, CLICK_INSTRUCTION, SELECTOR_MENTIONS, PANEL_STATE_KEY, PERSIAN_MONTHS } from "./constant";

let floatingPanel: HTMLElement | null = null;
let showButton: HTMLElement | null = null;
const convertedDates = new Map<string, { persianDate: string, element: HTMLElement }>();
let isPanelHidden = false;
let panelPosition = { top: '', left: '', right: '20px', bottom: '20px' };

export function handleDateMentions(persianInput: boolean): number {
  console.log(`${LOG_PREFIX} Handling date mentions, persianInput =`, persianInput);
  let convertedMentionCount = 0;

  try {
    if (persianInput) {
      loadPanelState();
      createFloatingPanel();

      const mentions = document.querySelectorAll<HTMLElement>(SELECTOR_MENTIONS);
      convertedDates.clear();

      mentions.forEach(reminder => {
        const currentText = reminder.textContent || "";
        const trimmedText = currentText.trim();
        if (!trimmedText || isPersianDate(trimmedText)) return;

        const dateInfo = extractDateFromMention(trimmedText);
        if (dateInfo) {
          const { date, display } = dateInfo;
          const jalali = jalaali.toJalaali(date);
          const persianDate = `${PERSIAN_MONTHS[jalali.jm - 1]} ${jalali.jd}، ${jalali.jy}`;

          convertedDates.set(display, { persianDate, element: reminder });
          convertedMentionCount++;
          console.log(`${LOG_PREFIX} Converted mention`, display, "to", persianDate);
        }
      });

      updatePanelContent();
      if (isPanelHidden) hidePanel(); else showPanel();
    } else {
      removeFloatingPanel();
      convertedDates.clear();
    }

    return convertedMentionCount;
  } catch (error) {
    console.error("Error handling date mentions:", error);
    return convertedMentionCount;
  }
}

function createFloatingPanel() {
  if (floatingPanel && document.body.contains(floatingPanel)) return;

  floatingPanel = document.createElement('div');
  floatingPanel.id = PANEL_ID;
  floatingPanel.style.cssText = `
    position: fixed;
    ${panelPosition.bottom ? 'bottom: ' + panelPosition.bottom + ';' : ''}
    ${panelPosition.right ? 'right: ' + panelPosition.right + ';' : ''}
    ${panelPosition.top ? 'top: ' + panelPosition.top + ';' : ''}
    ${panelPosition.left ? 'left: ' + panelPosition.left + ';' : ''}
    width: 280px;
    max-height: 400px;
    background: #ffffff;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, sans-serif;
    z-index: 9999;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    transition: opacity 0.2s ease, transform 0.2s ease;
  `;

  const header = document.createElement('div');
  header.style.cssText = `
    padding: 12px 16px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: move;
    background: #f7f6f3;
  `;
  header.innerHTML = `
    <div style="font-weight: 600; font-size: 14px;">${PANEL_TITLE}</div>
    <div style="display: flex; gap: 8px;">
      <button id="${MINIMIZE_BTN_ID}" style="
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      ">−</button>
      <button id="${HIDE_BTN_ID}" style="
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      ">×</button>
    </div>
  `;
  floatingPanel.appendChild(header);

  const content = document.createElement('div');
  content.id = CONTENT_ID;
  content.style.cssText = `
    padding: 16px;
    overflow-y: auto;
    max-height: 340px;
    display: block;
  `;
  floatingPanel.appendChild(content);

  document.body.appendChild(floatingPanel);
  makeDraggable(floatingPanel, header);

  const MinimizeBtn = floatingPanel.querySelector(`#${MINIMIZE_BTN_ID}`);
  if (MinimizeBtn) {
    MinimizeBtn.addEventListener('click', () => {
      const contentArea = floatingPanel?.querySelector(`#${CONTENT_ID}`) as HTMLElement;
      if (contentArea.style.display === 'none') {
        contentArea.style.display = 'block';
        (MinimizeBtn as HTMLElement).textContent = '−';
      } else {
        contentArea.style.display = 'none';
        (MinimizeBtn as HTMLElement).textContent = '+';
      }
    });
  }

  const hideBtn = floatingPanel.querySelector(`#${HIDE_BTN_ID}`);
  if (hideBtn) hideBtn.addEventListener('click', () => { hidePanel(); savePanelState(); });

  createShowButton();
}

function createShowButton() {
  if (showButton && document.body.contains(showButton)) document.body.removeChild(showButton);

  showButton = document.createElement('div');
  showButton.id = SHOW_BTN_ID;
  showButton.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 36px;
    height: 36px;
    background: #ffffff;
    border-radius: 18px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 9999;
    font-size: 18px;
    color: #333;
  `;
  showButton.innerHTML = `<span style="font-weight: bold;">🗓️</span>`;
  showButton.title = PANEL_TITLE;
  showButton.addEventListener('click', () => { showPanel(); savePanelState(); });
  document.body.appendChild(showButton);
}

function hidePanel() {
  if (!floatingPanel || !showButton) return;

  if (floatingPanel.style.top) panelPosition.top = floatingPanel.style.top;
  if (floatingPanel.style.left) panelPosition.left = floatingPanel.style.left;
  if (floatingPanel.style.right) panelPosition.right = floatingPanel.style.right;
  if (floatingPanel.style.bottom) panelPosition.bottom = floatingPanel.style.bottom;

  floatingPanel.style.display = 'none';
  showButton.style.display = 'flex';
  isPanelHidden = true;
}

function showPanel() {
  if (!floatingPanel || !showButton) return;

  floatingPanel.style.display = 'flex';
  showButton.style.display = 'none';
  isPanelHidden = false;
}

function savePanelState() {
  try {
    const state = { hidden: isPanelHidden, position: panelPosition };
    localStorage.setItem(PANEL_STATE_KEY, JSON.stringify(state));
  } catch (error) {
    console.error("Error saving panel state:", error);
  }
}

function loadPanelState() {
  try {
    const savedState = localStorage.getItem(PANEL_STATE_KEY);
    if (savedState) {
      const state = JSON.parse(savedState);
      isPanelHidden = state.hidden;
      if (state.position) panelPosition = state.position;
    }
  } catch (error) {
    console.error("Error loading panel state:", error);
  }
}

function updatePanelContent() {
  if (!floatingPanel) return;

  const content = floatingPanel.querySelector(`#${CONTENT_ID}`);
  if (!content) return;

  if (convertedDates.size === 0) {
    content.innerHTML = `
      <div style="text-align: center; color: #888; padding: 8px 0;">
        ${NO_DATES_MESSAGE}
      </div>
    `;
    return;
  }

  let html = '';
  convertedDates.forEach(({ persianDate, element }, gregorianDate) => {
    html += `
      <div style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #f0f0f0;">
        <div style="margin-bottom: 4px; direction: rtl; text-align: right;">
          <span style="font-weight: 600; cursor: pointer;" data-date="${gregorianDate}">${persianDate}</span>
        </div>
        <div style="font-size: 12px; color: #888;">
          ${gregorianDate}
        </div>
      </div>
    `;
  });

  html += `
    <div style="font-size: 12px; color: #888; margin-top: 8px; text-align: center;">
      ${CLICK_INSTRUCTION}
    </div>
  `;
  content.innerHTML = html;

  const dateElements = content.querySelectorAll('span[data-date]');
  dateElements.forEach(element => {
    element.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      const gregorianDate = target.getAttribute('data-date');
      if (!gregorianDate) return;

      const conversion = convertedDates.get(gregorianDate);
      if (!conversion) return;

      conversion.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
      const originalElement = conversion.element;
      originalElement.style.backgroundColor = '#fff3cd';
      setTimeout(() => { originalElement.style.backgroundColor = ''; }, 2000);
    });
  });
}

function showCopyToast(message: string) {
  const existingToast = document.getElementById(TOAST_ID);
  if (existingToast) document.body.removeChild(existingToast);

  const toast = document.createElement('div');
  toast.id = TOAST_ID;
  toast.style.cssText = `
    position: fixed;
    bottom: 60px;
    right: 20px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 14px;
    z-index: 10000;
  `;
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => { if (document.body.contains(toast)) document.body.removeChild(toast); }, 2000);
}

function removeFloatingPanel() {
  if (floatingPanel && document.body.contains(floatingPanel)) {
    document.body.removeChild(floatingPanel);
    floatingPanel = null;
  }
  if (showButton && document.body.contains(showButton)) {
    document.body.removeChild(showButton);
    showButton = null;
  }
}

function makeDraggable(element: HTMLElement, handle: HTMLElement) {
  let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  handle.onmousedown = dragMouseDown;

  function dragMouseDown(e: MouseEvent) {
    e.preventDefault();
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;
  }

  function elementDrag(e: MouseEvent) {
    e.preventDefault();
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    element.style.top = (element.offsetTop - pos2) + "px";
    element.style.left = (element.offsetLeft - pos1) + "px";
    element.style.right = 'auto';
    element.style.bottom = 'auto';
    panelPosition = { top: element.style.top, left: element.style.left, right: '', bottom: '' };
  }

  function closeDragElement() {
    document.onmouseup = null;
    document.onmousemove = null;
    savePanelState();
  }
}

function extractDateFromMention(text: string): { date: Date, display: string } | null {
  try {
    const cleaned = text.replace(/\s+/g, ' ').trim();
    const date = parseGregorian(cleaned);
    if (date) return { date, display: cleaned };
    return null;
  } catch (error) {
    console.error("Error extracting date from mention:", error);
    return null;
  }
}

export function clearDateMentionConversions(): number {
  console.log(`${LOG_PREFIX} Clearing date mention conversions`);
  const count = convertedDates.size;
  convertedDates.clear();
  removeFloatingPanel();
  return count;
}
+++++
convertPageCalendar.ts
import jalaali from 'jalaali-js';
import { PERSIAN_MONTHS, SYSTEM_FONTS, STORAGE_KEYS, DEFAULT_FONT } from "./constant";

const MONTHS: { [key: string]: number } = {
  January: 1, February: 2, March: 3, April: 4, May: 5, June: 6,
  July: 7, August: 8, September: 9, October: 10, November: 11, December: 12,
  Jan: 1, Feb: 2, Mar: 3, Apr: 4, Jun: 6, Jul: 7, Aug: 8, Sep: 9, Oct: 10, Nov: 11, Dec: 12
};

const persianDayNames: { [key in 'Sun' | 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri' | 'Sat']: string } = {
  Sun: "یکشنبه", Mon: "دوشنبه", Tue: "سه‌شنبه",
  Wed: "چهارشنبه", Thu: "پنج‌شنبه", Fri: "جمعه", Sat: "شنبه"
};

function toPersianDigits(input: string): string {
  return input.replace(/\d/g, d => "۰۱۲۳۴۵۶۷۸۹"[+d]);
}

let currentFont = DEFAULT_FONT;

function getHeaderElement(): HTMLElement | null {
  return document.querySelector('.notion-calendar-view > div:first-child div[style*="font-weight: 600"]') as HTMLElement | null;
}

function convertPageCalendarHeader(): void {
  const headerEl = getHeaderElement();
  if (!headerEl) return;
  // Save original header if not saved
  if (!headerEl.getAttribute('data-original-header')) {
    headerEl.setAttribute('data-original-header', headerEl.textContent || "");
  }
  const orig = headerEl.getAttribute('data-original-header') || "";
  const parts = orig.split(/\s+/);
  if (parts.length < 2) return;
  const monthName = parts[0],
        year = parseInt(parts[1]),
        monthNum = MONTHS[monthName];
  if (!monthNum || isNaN(year)) return;
  const gregDate = new Date(year, monthNum - 1, 1),
        jDate = jalaali.toJalaali(gregDate),
        persianMonth = PERSIAN_MONTHS[jDate.jm - 1],
        persianYear = toPersianDigits(jDate.jy.toString());
  headerEl.textContent = `${persianMonth} ${persianYear}`;
  headerEl.setAttribute('dir', 'rtl');
  headerEl.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
}

function convertPageCalendarDayNames(): void {
  const dayNameEls = document.querySelectorAll('.notion-calendar-header-days > div');
  dayNameEls.forEach(el => {
    const htmlEl = el as HTMLElement;
    const original = htmlEl.textContent?.trim();
    if (original && original in persianDayNames) {
      htmlEl.textContent = persianDayNames[original as keyof typeof persianDayNames];
      htmlEl.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
      htmlEl.style.direction = 'rtl';
    }
  });
}

function convertPageCalendarDays(): void {
  const dayEls = document.querySelectorAll('.notion-calendar-view-day') as NodeListOf<HTMLElement>;
  const headerEl = getHeaderElement();
  if (!headerEl) return;
  const orig = headerEl.getAttribute('data-original-header') || "";
  const parts = orig.split(/\s+/);
  if (parts.length < 2) return;
  const headerMonthName = parts[0],
        headerYear = parseInt(parts[1]),
        headerMonthNum = MONTHS[headerMonthName];
  if (!headerMonthNum || isNaN(headerYear)) return;
  let currentDate = new Date(headerYear, headerMonthNum - 1, 1);
  dayEls.forEach(htmlEl => {
    let text = htmlEl.textContent?.trim() || "";
    const monthMatch = text.match(/^(Jan|Feb|Mar|Apr|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/);
    if (monthMatch) {
      const monthAbbr = monthMatch[0],
            dayMatch = text.match(/\d+/);
      if (dayMatch) {
        const dayNum = parseInt(dayMatch[0]),
              newMonth = MONTHS[monthAbbr];
        let newYear = currentDate.getFullYear();
        if (newMonth < (currentDate.getMonth() + 1)) newYear++;
        currentDate = new Date(newYear, newMonth - 1, dayNum);
      }
    }
    const jDate = jalaali.toJalaali(currentDate);
    htmlEl.textContent = toPersianDigits(jDate.jd.toString());
    htmlEl.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
    htmlEl.style.direction = 'rtl';
    currentDate.setDate(currentDate.getDate() + 1);
  });
}

export function convertPageCalendar(): void {
  convertPageCalendarHeader();
  convertPageCalendarDayNames();
  convertPageCalendarDays();
}

function setupObserver(selector: string, callback: () => void): void {
  const container = document.querySelector(selector);
  if (!container) return;
  const observer = new MutationObserver(callback);
  observer.observe(container, { childList: true, subtree: true, characterData: true });
}

chrome.storage.onChanged.addListener((changes, area) => {
  if (area === 'sync' && (changes[STORAGE_KEYS.PERSIAN_INPUT] || changes[STORAGE_KEYS.SELECTED_FONT])) {
    chrome.storage.sync.get([STORAGE_KEYS.PERSIAN_INPUT, STORAGE_KEYS.SELECTED_FONT], data => {
      currentFont = data[STORAGE_KEYS.SELECTED_FONT] || DEFAULT_FONT;
      if (data[STORAGE_KEYS.PERSIAN_INPUT]) convertPageCalendar();
    });
  }
});

chrome.storage.sync.get([STORAGE_KEYS.PERSIAN_INPUT, STORAGE_KEYS.SELECTED_FONT], data => {
  currentFont = data[STORAGE_KEYS.SELECTED_FONT] || DEFAULT_FONT;
  if (data[STORAGE_KEYS.PERSIAN_INPUT]) {
    convertPageCalendar();
    setupObserver('.notion-calendar-view', convertPageCalendar);
    setupObserver('.notion-calendar-header-days', convertPageCalendarDayNames);
    let timer: number | null = null;
    window.addEventListener('scroll', () => {
      if (timer) clearTimeout(timer);
      timer = window.setTimeout(() => convertPageCalendar(), 300);
    });
  }
});

+++++
fontInjection.ts
import { UNICODE_RANGE, DEFAULT_FONTS, ALL_FONTS_CSS, SELECTOR_EDITABLE_TEXT, SELECTOR_CODE_BLOCK, SELECTOR_NUMBERED_LIST, SELECTOR_QUOTE_BLOCK, SELECTOR_TOGGLE_BLOCK, SELECTOR_BULLETED_LIST, SELECTOR_TABLE_BLOCK, SELECTOR_TODO_BLOCK, SELECTOR_RTL_ELEMENTS, SELECTOR_GLOBAL_FONTS, DEFAULT_FONT, SYSTEM_FONTS, STORAGE_KEYS } from "./constant";

let fontStyleElement: HTMLStyleElement | null = null;
let observer: MutationObserver | null = null;
let currentFont: string = DEFAULT_FONT;

function toPersianDigits(input: string): string {
  return input.replace(/\d/g, d => "۰۱۲۳۴۵۶۷۸۹"[parseInt(d)]);
}

function containsPersianArabic(text: string): boolean {
  const persianArabicRegex = /[\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]/;
  return persianArabicRegex.test(text);
}

function processTextNode(node: Text): void {
  const text = node.textContent || '';
  if (!containsPersianArabic(text)) return;
  const container = node.parentElement?.closest(SELECTOR_EDITABLE_TEXT) as HTMLElement;
  if (!container || container.closest(SELECTOR_CODE_BLOCK)) return;
  container.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
  container.style.direction = 'rtl';
  container.style.textAlign = 'right';
}

function processSubtree(root: Node): void {
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  let node: Text | null;
  while ((node = walker.nextNode() as Text)) processTextNode(node);
}

function updateNumberedListBlock(block: Element): void {
  const pseudo = block.querySelector('.pseudoBefore') as HTMLElement | null;
  if (pseudo) {
    let content = pseudo.style.getPropertyValue('--pseudoBefore--content') || pseudo.textContent || "";
    content = content.replace(/["']/g, "").trim();
    const persianContent = toPersianDigits(content);
    pseudo.style.removeProperty("--pseudoBefore--content");
    pseudo.textContent = persianContent;
    pseudo.style.direction = 'rtl';
    pseudo.style.textAlign = 'right';
  }
}

function applyRTLToNumberedLists(): void {
  document.querySelectorAll(SELECTOR_NUMBERED_LIST).forEach((block: Element) => {
    if (containsPersianArabic(block.textContent || "")) {
      updateNumberedListBlock(block);
      (block as HTMLElement).style.direction = 'rtl';
      (block as HTMLElement).style.textAlign = 'right';
    }
  });
}

function applyRTLToQuotes(): void {
  document.querySelectorAll(SELECTOR_QUOTE_BLOCK).forEach((block: Element) => {
    if (containsPersianArabic(block.textContent || "")) {
      const bq = block.querySelector("blockquote") as HTMLElement | null;
      if (bq) {
        const inner = bq.querySelector("div[style*='border-left']") as HTMLElement | null;
        if (inner) {
          const computed = window.getComputedStyle(inner);
          const originalPaddingLeft = computed.paddingLeft;
          const originalPaddingRight = computed.paddingRight;
          inner.style.borderLeft = "none";
          inner.style.borderRight = "3px solid currentcolor";
          inner.style.paddingLeft = originalPaddingRight;
          inner.style.paddingRight = originalPaddingLeft;
        }
        bq.style.direction = "rtl";
        bq.style.textAlign = "right";
      }
    }
  });
}

function applyRTLToToggleBlocks(): void {
  document.querySelectorAll(SELECTOR_TOGGLE_BLOCK).forEach((block: Element) => {
    if (containsPersianArabic(block.textContent || "")) {
      const toggleBlock = block as HTMLElement;
      toggleBlock.style.textAlign = "right";
      const flexContainer = toggleBlock.firstElementChild as HTMLElement | null;
      if (flexContainer) flexContainer.style.setProperty("flex-direction", "row-reverse", "important");
    }
  });
}

function applyAdditionalRTLLogic(): void {
  document.querySelectorAll(SELECTOR_BULLETED_LIST).forEach((block: Element) => {
    (block as HTMLElement).setAttribute("dir", "rtl");
  });
  document.querySelectorAll(SELECTOR_TABLE_BLOCK).forEach((block: Element) => {
    if (Array.from(block.querySelectorAll("*")).some(el => containsPersianArabic(el.textContent || ""))) {
      (block as HTMLElement).setAttribute("dir", "rtl");
    }
  });
  document.querySelectorAll(SELECTOR_TODO_BLOCK).forEach((block: Element) => {
    if (Array.from(block.querySelectorAll("*")).some(el => containsPersianArabic(el.textContent || ""))) {
      (block as HTMLElement).setAttribute("dir", "rtl");
    }
  });
}

function applyRTLToNewParts(): void {
  document.querySelectorAll(SELECTOR_RTL_ELEMENTS).forEach((el: Element) => {
    if (containsPersianArabic(el.textContent || "")) {
      const element = el as HTMLElement;
      element.style.direction = "rtl";
      element.style.textAlign = "right";
      element.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
    }
  });
}

function applyGlobalFontStyles(): void {
  document.querySelectorAll(SELECTOR_GLOBAL_FONTS).forEach((el: Element) => {
    (el as HTMLElement).style.setProperty("font-family", `${currentFont}, ${SYSTEM_FONTS}`, "important");
  });
}

function setupObserver(): void {
  if (observer) return;
  observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === 'childList') {
        mutation.addedNodes.forEach(node => { if (node.nodeType === Node.ELEMENT_NODE) processSubtree(node); });
      } else if (mutation.type === 'characterData') {
        processTextNode(mutation.target as Text);
      }
    }
    applyAdditionalRTLLogic();
    applyGlobalFontStyles();
    applyRTLToNewParts();
    applyRTLToNumberedLists();
    applyRTLToQuotes();
    applyRTLToToggleBlocks();
  });
  observer.observe(document.body, { childList: true, subtree: true, characterData: true });
  processSubtree(document.body);
  applyAdditionalRTLLogic();
  applyGlobalFontStyles();
  applyRTLToNewParts();
  applyRTLToNumberedLists();
  applyRTLToQuotes();
  applyRTLToToggleBlocks();
}

function cleanupObserver(): void {
  if (observer) { observer.disconnect(); observer = null; }
}

export function saveSelectedFont(fontFamily: string): Promise<void> {
  return new Promise((resolve) => {
    chrome.storage.sync.set({ [STORAGE_KEYS.SELECTED_FONT]: fontFamily }, () => resolve());
  });
}

export function loadSelectedFont(): Promise<string> {
  return new Promise((resolve) => {
    chrome.storage.sync.get([STORAGE_KEYS.SELECTED_FONT], (result) => resolve(result[STORAGE_KEYS.SELECTED_FONT] || DEFAULT_FONT));
  });
}

export function setCurrentFont(fontFamily: string): void {
  currentFont = fontFamily;
  if (fontStyleElement) {
    document.querySelectorAll(SELECTOR_EDITABLE_TEXT).forEach((el: Element) => {
      const element = el as HTMLElement;
      if (containsPersianArabic(element.textContent || '')) {
        element.style.fontFamily = `${currentFont}, ${SYSTEM_FONTS}`;
      }
    });
  }
  applyGlobalFontStyles();
  applyRTLToNewParts();
  applyRTLToNumberedLists();
  applyRTLToQuotes();
  applyRTLToToggleBlocks();
}

export function injectFonts(enabled: boolean): void {
  if (enabled) {
    loadSelectedFont().then((fontFamily) => {
      currentFont = fontFamily;
      if (!fontStyleElement) {
        fontStyleElement = document.createElement('style');
        fontStyleElement.textContent = ALL_FONTS_CSS;
        document.head.appendChild(fontStyleElement);
      }
      setupObserver();
    });
  } else {
    if (fontStyleElement) { fontStyleElement.remove(); fontStyleElement = null; }

    document.querySelectorAll(SELECTOR_EDITABLE_TEXT).forEach((el: Element) => {
      const element = el as HTMLElement;
      element.style.fontFamily = '';
      element.style.direction = '';
      element.style.textAlign = '';
    });

    document.querySelectorAll(SELECTOR_GLOBAL_FONTS).forEach((el: Element) => {
      (el as HTMLElement).style.removeProperty("font-family");
    });

    document.querySelectorAll(SELECTOR_RTL_ELEMENTS).forEach((el: Element) => {
      const element = el as HTMLElement;
      element.style.direction = '';
      element.style.textAlign = '';
      element.style.fontFamily = '';
    });

    document.querySelectorAll(SELECTOR_NUMBERED_LIST).forEach((block: Element) => {
      (block as HTMLElement).style.direction = '';
      (block as HTMLElement).style.textAlign = '';
      const pseudo = block.querySelector('.pseudoBefore') as HTMLElement | null;
      if (pseudo) {
        pseudo.style.direction = '';
        pseudo.style.textAlign = '';
      }
    });

    document.querySelectorAll(SELECTOR_QUOTE_BLOCK).forEach((block: Element) => {
      const bq = block.querySelector("blockquote") as HTMLElement | null;
      if (bq) {
        const inner = bq.querySelector("div[style*='border-right']") as HTMLElement | null;
        if (inner) {
          inner.style.borderRight = "none";
          inner.style.borderLeft = "3px solid currentcolor";
          inner.style.paddingLeft = "";
          inner.style.paddingRight = "";
        }
        bq.style.direction = "";
        bq.style.textAlign = "";
      }
    });

    document.querySelectorAll(SELECTOR_TOGGLE_BLOCK).forEach((block: Element) => {
      const toggleBlock = block as HTMLElement;
      toggleBlock.style.textAlign = "";
      const flexContainer = toggleBlock.firstElementChild as HTMLElement | null;
      if (flexContainer) flexContainer.style.removeProperty("flex-direction");
    });

    document.querySelectorAll(`${SELECTOR_BULLETED_LIST}, ${SELECTOR_TABLE_BLOCK}, ${SELECTOR_TODO_BLOCK}`).forEach((block: Element) => {
      (block as HTMLElement).removeAttribute("dir");
    });

    cleanupObserver();
  }
}
+++++
convertText.ts
import { parseGregorian, formatJalali } from "./dateUtils";
import { LOG_PREFIX, DATASET_KEYS, SELECTOR_REMINDERS } from "./constant";

export function convertReminderDates(persianInput: boolean) {
  document.querySelectorAll<HTMLElement>(SELECTOR_REMINDERS).forEach(el => {
    const currentText = el.innerText.trim();
    const match = currentText.match(/^(.+?)(\s+\d{1,2}:\d{2}\s*(AM|PM))?$/i);
    if (!match) return;

    const datePart = match[1];
    const timePart = match[2] || "";
    let originalDate = el.dataset[DATASET_KEYS.ORIGINAL_DATE];
    if (!originalDate) {
      originalDate = currentText;
      el.dataset[DATASET_KEYS.ORIGINAL_DATE] = originalDate;
    }

    if (persianInput) {
      const date = parseGregorian(datePart);
      if (date && !isNaN(date.getTime())) {
        const jalaliDate = formatJalali(date);
        const newText = jalaliDate + timePart;
        if (newText !== currentText) {
          console.log(`${LOG_PREFIX} Converting reminder date`, originalDate, "to", newText);
          el.innerText = newText;
          el.title = originalDate;
          el.dataset[DATASET_KEYS.CONVERTED] = "true";
        }
      }
    } else {
      if (el.dataset[DATASET_KEYS.CONVERTED] === "true") {
        console.log(`${LOG_PREFIX} Reverting reminder date`, originalDate);
        el.innerText = originalDate;
        el.title = "";
        delete el.dataset[DATASET_KEYS.CONVERTED];
      }
    }
  });
}
+++++
background.ts
import { STORAGE_KEYS, MESSAGE_TYPES, NOTION_URL_PATTERN } from "../constant";

function applySettingsToTab(tabId: number) {
  chrome.storage.sync.get(
    [STORAGE_KEYS.PERSIAN_INPUT, STORAGE_KEYS.FONT_INJECTION_ENABLED, STORAGE_KEYS.SELECTED_FONT],
    (data) => {
      chrome.tabs.sendMessage(tabId, { type: MESSAGE_TYPES.APPLY_SETTINGS, data });
    }
  );
}

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (tab.url && tab.url.includes("notion.so") && changeInfo.status === 'complete') {
    applySettingsToTab(tabId);
  } else {
    chrome.action.disable(tabId);
  }
});

chrome.tabs.onActivated.addListener((activeInfo) => {
  chrome.tabs.get(activeInfo.tabId, (tab) => {
    if (tab && tab.url && tab.url.includes("notion.so") && tab.id !== undefined) {
      applySettingsToTab(tab.id);
    }
  });
});

chrome.storage.onChanged.addListener((changes, namespace) => {
  if (namespace === 'sync' && (changes[STORAGE_KEYS.PERSIAN_INPUT] || changes[STORAGE_KEYS.FONT_INJECTION_ENABLED] || changes[STORAGE_KEYS.SELECTED_FONT])) {
    chrome.tabs.query({ url: NOTION_URL_PATTERN }, (tabs) => {
      tabs.forEach((tab) => {
        if (tab.id) applySettingsToTab(tab.id);
      });
    });
  }
});
+++++
state.ts
import { persianToggle, fontToggle, fontSelectorContainer, fontSelector, updateFontAuthor } from "./ui";
import { checkForErrors } from "./events";
import { STORAGE_KEYS } from "../constant";

export function loadState() {
  chrome.storage.sync.get([STORAGE_KEYS.PERSIAN_INPUT, STORAGE_KEYS.FONT_INJECTION_ENABLED, STORAGE_KEYS.SELECTED_FONT], data => {
    persianToggle.checked = !!data[STORAGE_KEYS.PERSIAN_INPUT];
    fontToggle.checked = !!data[STORAGE_KEYS.FONT_INJECTION_ENABLED];
    if (data[STORAGE_KEYS.FONT_INJECTION_ENABLED]) {
      fontSelectorContainer.classList.add('visible');
    } else {
      fontSelectorContainer.classList.remove('visible');
    }
    if (data[STORAGE_KEYS.SELECTED_FONT]) {
      fontSelector.value = data[STORAGE_KEYS.SELECTED_FONT];
    }
    if (data[STORAGE_KEYS.PERSIAN_INPUT]) {
      checkForErrors();
    }
  });
}
+++++
popup.html
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>نوشن فارسی</title>
  <link rel="stylesheet" href="popup.css">
</head>
<body>
  <div class="container">

    <!-- settings -->
    <div id="settings-page" style="display:none;">
      <h3>تنظیمات افزونه</h3>
      <div class="toggle-row" style="position: relative; margin-bottom: 15px;">
        <label class="switch">
          <input type="checkbox" id="persian-numbers-toggle">
          <span class="slider"></span>
        </label>
        <label for="persian-numbers-toggle" class="toggle-label">اعداد فارسی در تاریخ‌ها</label>
      </div>
      <button id="settings-back" class="blue-btn">بازگشت</button>
    </div>
    

    <!-- main -->
    <div id="main-page">

      <div class="badge-experimental">آزمایشی</div>
      <div class="logo-container">
        <img src="assets/icons/notionfarsi_logo.svg" alt="Notion Farsi Logo" class="logo">
        <span class="header-text">نوشن فارسی</span>
      </div>

      <div class="toggle-row" style="top:68px;">
        <label class="switch">
          <input type="checkbox" id="persian-toggle" checked>
          <span class="slider"></span>
        </label>
        <label for="persian-toggle" class="toggle-label">تاریخ شمسی</label>
        <div class="icon-wrap">
          <img src="assets/icons/calendar_icon.svg" alt="Calendar Icon">
        </div>
      </div>

      <div class="toggle-row" style="top:109px;">
        <label class="switch">
          <input type="checkbox" id="font-toggle" checked>
          <span class="slider"></span>
        </label>
        <label for="font-toggle" class="toggle-label">فونت فارسی</label>
        <div class="icon-wrap">
          <img src="assets/icons/farsi_icon.svg" alt="Farsi Icon">
        </div>
      </div>

      <div id="font-selector-container" class="font-selector-container">
        <select id="font-selector"></select>
      </div>

      <div id="call-message">اگه چیزی خراب بود، یه خبر بهم بده 🐞</div>
      <hr class="separator">

      <div class="footer">
        <a href="https://github.com/truthofmatthew" target="_blank" class="social github">
          <img src="assets/icons/GitHub_Icon.svg" alt="GitHub">
        </a>
        <a href="https://www.linkedin.com/in/truthofmatthew/" target="_blank" class="social linkedin">
          <img src="assets/icons/Linkedin_Icon.svg" alt="LinkedIn">
        </a>
        <a href="#" id="settings-gear" class="social gear" title="تنظیمات">
          
          <svg fill="currentColor" width="24px" height="24px" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><path d="M25 34c-5 0-9-4-9-9s4-9 9-9 9 4 9 9-4 9-9 9zm0-16c-3.9 0-7 3.1-7 7s3.1 7 7 7 7-3.1 7-7-3.1-7-7-7z"/><path d="M27.7 44h-5.4l-1.5-4.6c-1-.3-2-.7-2.9-1.2l-4.4 2.2-3.8-3.8 2.2-4.4c-.5-.9-.9-1.9-1.2-2.9L6 27.7v-5.4l4.6-1.5c.3-1 .7-2 1.2-2.9l-2.2-4.4 3.8-3.8 4.4 2.2c.9-.5 1.9-.9 2.9-1.2L22.3 6h5.4l1.5 4.6c1 .3 2 .7 2.9 1.2l4.4-2.2 3.8 3.8-2.2 4.4c.5.9.9 1.9 1.2 2.9l4.6 1.5v5.4l-4.6 1.5c-.3 1-.7 2-1.2 2.9l2.2 4.4-3.8 3.8-4.4-2.2c-.9.5-1.9.9-2.9 1.2L27.7 44zm-4-2h2.6l1.4-4.3.5-.1c1.2-.3 2.3-.8 3.4-1.4l.5-.3 4 2 1.8-1.8-2-4 .3-.5c.6-1 1.1-2.2 1.4-3.4l.1-.5 4.3-1.4v-2.6l-4.3-1.4-.1-.5c-.3-1.2-.8-2.3-1.4-3.4l-.3-.5 2-4-1.8-1.8-4 2-.5-.3c-1.1-.6-2.2-1.1-3.4-1.4l-.5-.1L26.3 8h-2.6l-1.4 4.3-.5.1c-1.2.3-2.3.8-3.4 1.4l-.5.3-4-2-1.8 1.8 2 4-.3.5c-.6 1-1.1 2.2-1.4 3.4l-.1.5L8 23.7v2.6l4.3 1.4.1.5c.3 1.2.8 2.3 1.4 3.4l.3.5-2 4 1.8 1.8 4-2 .5.3c1.1.6 2.2 1.1 3.4 1.4l.5.1 1.4 4.3z"/></svg>

        </a>
        <div class="avatar">
          <img src="assets/icons/boy_icon.svg" alt="Boy Icon">
        </div>
        <span class="footer-name">Matthew Truth</span>
      </div>

    </div>

  </div>

  <script src="popup.js"></script>
</body>
</html>

+++++
popup.ts
import { initFontSelector } from "./ui";
import { initListeners } from "./events";
import { loadState } from "./state";
import { MESSAGE_TYPES, STORAGE_KEYS } from "../constant";

initFontSelector();
loadState();
initListeners();

const settingsGear = document.getElementById("settings-gear") as HTMLElement;
const mainPage = document.getElementById("main-page") as HTMLElement;
const settingsPage = document.getElementById("settings-page") as HTMLElement;
const backBtn = document.getElementById("settings-back") as HTMLElement;
const persianNumbersToggle = document.getElementById("persian-numbers-toggle") as HTMLInputElement;

// load toggle state
chrome.storage.sync.get([STORAGE_KEYS.PERSIAN_NUMBERS], (data) => {
    persianNumbersToggle.checked = !!data[STORAGE_KEYS.PERSIAN_NUMBERS];
});

// save toggle state
persianNumbersToggle.addEventListener("change", () => {
    chrome.storage.sync.set({ [STORAGE_KEYS.PERSIAN_NUMBERS]: persianNumbersToggle.checked }, () => {
        chrome.tabs.query({ active: true, currentWindow: true }, tabs => {
            if (tabs[0]?.id) {
                chrome.tabs.sendMessage(tabs[0].id, { type: MESSAGE_TYPES.REFRESH_CONVERSION });
            }
        });
    });
});


// show settings
settingsGear.addEventListener("click", () => {
    mainPage.style.display = "none";
    settingsPage.style.display = "block";
});

// back to main
backBtn.addEventListener("click", () => {
    settingsPage.style.display = "none";
    mainPage.style.display = "block";
});

+++++
events.ts
import { persianToggle, fontToggle, resetButton, errorMessageEl, fontSelector, fontSelectorContainer, updateFontAuthor, showErrorMessage } from "./ui";
import { saveSelectedFont } from "../fontInjection";
import { STORAGE_KEYS, MESSAGE_TYPES } from "../constant";

let altKeyPressed = false;

export function initListeners() {
  persianToggle.addEventListener("change", () => {
    const enabled = persianToggle.checked;
    chrome.storage.sync.set({ [STORAGE_KEYS.PERSIAN_INPUT]: enabled });
    chrome.tabs.query({ active: true, currentWindow: true }, tabs => {
      if (tabs[0]?.id) {
        chrome.tabs.sendMessage(tabs[0].id, { persianInput: enabled });
      }
    });
    if (!enabled) {
      errorMessageEl.style.display = 'none';
    } else {
      setTimeout(checkForErrors, 1000);
    }
  });

  fontToggle.addEventListener('change', () => {
    const enabled = fontToggle.checked;
    chrome.storage.sync.set({ [STORAGE_KEYS.FONT_INJECTION_ENABLED]: enabled });
    if (enabled) {
      fontSelectorContainer.classList.add('visible');
    } else {
      fontSelectorContainer.classList.remove('visible');
    }
    chrome.tabs.query({ active: true, currentWindow: true }, tabs => {
      if (tabs[0]?.id) {
        chrome.tabs.sendMessage(tabs[0].id, { fontInjectionEnabled: enabled });
      }
    });
  });

  fontSelector.addEventListener('change', () => {
    const selectedFont = fontSelector.value;
    saveSelectedFont(selectedFont).then(() => {
      chrome.tabs.query({ active: true, currentWindow: true }, tabs => {
        if (tabs[0]?.id) {
          chrome.tabs.sendMessage(tabs[0].id, { selectedFont });
        }
      });
    });
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Alt') {
      altKeyPressed = true;
      resetButton.textContent = "Force Reload Page";
    }
  });

  document.addEventListener('keyup', (e) => {
    if (e.key === 'Alt') {
      altKeyPressed = false;
      resetButton.textContent = "Reset All Dates";
    }
  });

  chrome.runtime.onMessage.addListener((message) => {
    if (message[MESSAGE_TYPES.RESET_COMPLETE]) {
      if (!message.reloading) {
        resetButton.disabled = false;
        setTimeout(checkForErrors, 500);
      }
    }
    if (message[MESSAGE_TYPES.ERROR_COUNT_CHANGED] !== undefined) {
      if (message.errorCount > 0) {
        showErrorMessage(message.errorCount);
      } else {
        errorMessageEl.style.display = 'none';
      }
    }
  });
}

export function checkForErrors() {
  chrome.tabs.query({ active: true, currentWindow: true }, tabs => {
    if (tabs[0]?.id) {
      chrome.tabs.sendMessage(tabs[0].id, { [MESSAGE_TYPES.CHECK_ERRORS]: true }, (response) => {
        if (chrome.runtime.lastError) return;
        if (response && response.errorCount > 0) {
          showErrorMessage(response.errorCount);
        } else {
          errorMessageEl.style.display = 'none';
        }
      });
    }
  });
}
+++++
ui.ts
import { DEFAULT_FONTS, UI_ELEMENTS } from "../constant";

export const persianToggle = document.getElementById(UI_ELEMENTS.PERSIAN_TOGGLE) as HTMLInputElement;
export const fontToggle = document.getElementById(UI_ELEMENTS.FONT_TOGGLE) as HTMLInputElement;
export const resetButton = document.getElementById(UI_ELEMENTS.RESET_BUTTON) as HTMLButtonElement;
export const errorMessageEl = document.getElementById(UI_ELEMENTS.ERROR_MESSAGE) as HTMLDivElement;
export const fontSelectorContainer = document.getElementById(UI_ELEMENTS.FONT_SELECTOR_CONTAINER) as HTMLDivElement;
export const fontSelector = document.getElementById(UI_ELEMENTS.FONT_SELECTOR) as HTMLSelectElement;
export const fontAuthor = document.getElementById(UI_ELEMENTS.FONT_AUTHOR) as HTMLDivElement;
export const statusEl = document.getElementById(UI_ELEMENTS.STATUS) as HTMLDivElement;

export function initFontSelector() {
  fontSelector.innerHTML = '';
  DEFAULT_FONTS.forEach(font => {
    const option = document.createElement('option');
    option.value = font.en_name;
    option.textContent = font.fa_name;
    option.dataset.author = font.creator;
    fontSelector.appendChild(option);
  });
}

export function updateFontAuthor() {
  const selectedOption = fontSelector.options[fontSelector.selectedIndex];
  fontAuthor.textContent = selectedOption?.dataset.author ? `By: ${selectedOption.dataset.author}` : '';
}

export function updateStatus(message: string) {
  if (statusEl) statusEl.textContent = message;
}

export function showErrorMessage(count: number) {
  errorMessageEl.style.display = 'block';
  errorMessageEl.innerHTML = `
    <p>⚠️ ${count} conversion errors detected!</p>
    <p>Some dates might be displaying incorrectly. Try the "Reset All Dates" button to fix.</p>
  `;
}
+++++
popup.css
.container {
  position: relative;
  width: 300px;
  height: 273px;
  background: #fffdfa;
  margin: 0 auto;
  font-family: 'Vazirmatn', sans-serif;
}

.badge-experimental {
  position: absolute;
  top: 18px;
  left: 22px;
  width: 36px;
  height: 18px;
  background: #ea4e43;
  color: #fff;
  font-size: 8px;
  font-weight: 900;
  text-align: center;
  line-height: 18px;
  border-radius: 4px;
}

.logo-container {
  position: absolute;
  top: 15px;
  left: 186px;
}

.logo {
  position: absolute;
  top: 0;
  left: 74px;
  width: 23px;
  height: 22px;
}

.header-text {
  padding-left: 5px;
  font-size: 12.5px;
  font-weight: bold;
  color: #050505;
  line-height: 19px;
}

.toggle-row {
  position: absolute;
  left: 22px;
  width: 256px;
  height: 26px;
}

.switch {
  position: absolute;
  top: 2px;
  left: 0;
  width: 34px;
  height: 18px;
}
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: #ccc;
  transition: .2s;
  border-radius: 4px;
}
.slider:before {
  position: absolute;
  content: "";
  height: 14px;
  width: 14px;
  left: 2px;
  bottom: 2px;
  background-color: #fff;
  transition: .2s;
  border-radius: 20%;
}
.switch input:checked + .slider {
  background-color: #2F80ED;
}
.switch input:checked + .slider:before {
  transform: translateX(16px);
}

.toggle-label {
  position: absolute;
  top: 0;
  right: 25px;
  font-size: 12px;
  cursor: pointer;
}

.icon-wrap {
  top: 3px;
  width: 40px;
  height: 21px;
}

.icon-wrap img {
  position: absolute;
  top: 0;
  right: -4px;
  width: 20px;
  height: 20px;
}

.separator {
  position: absolute;
  top: 225px;
  left: 10px;
  width: 280px;
  border: none;
  height: 1px;
  background: #ccc;
}

.footer {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 34px;
}

.social {
  position: absolute;
  top: 4px;
  width: 24px;
  height: 24px;
  background: #fff;
  border: 1px solid rgba(0,0,0,0.15);
  border-radius: 5px;
}

 
.gear{
  right: 84px;
  color: #2F80ED;
}

.github {
  right: 48px;
}

.linkedin {
  right: 12px;
}

.social img {
  position: absolute;
  width: 14px;
  height: 14px;
  top: 5px;
  left: 5px;
}

.avatar {
  position: absolute;
  top: 5px;
  left: 10px;
  width: 24px;
  height: 24px;
}

.avatar img {
  width: 100%;
  height: 100%;
}

.footer-name {
  position: absolute;
  top: 12px;
  left: 42px;
  font-size: 10px;
  font-weight: 600;
  color: #000000;
}

.font-selector-container {
  position: absolute;
  top: 152px;
  left: 18px;
  display: flex;
  align-items: center;
  font-size: 10px;
}

.font-selector-container.visible {
  display: block;
}
.font-selector-container select {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background: url('assets/icons/arrow_down.svg') no-repeat right 10px center / 12px auto;
  padding-right: 30px;
  font-family: 'Vazirmatn', sans-serif;
  width: 266px;
  height: 36px;
  border: 1px solid #ccc;
  border-radius: 6px;
  font-size: 14px;
}
.font-selector-container .font-author {
  font-size: 12px;
  color: #777;
  margin-top: 4px;
  font-style: italic;
}

#call-message {
  text-align: center;
  padding-top: 200px;
  font-size: 13px;
}

.blue-btn {
  width: 100%;
  padding: 8px;
  margin-top: 20px;
  background: #2F80ED;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-family: 'Vazirmatn', sans-serif;
}

.blue-btn:hover {
  background: #2566c7;
}

+++++
content.ts
import { convertTableDates, resetAllConversions, isDateConversionInProgress, wasDateConversionRecent, getErrorCount } from "../tableDateConverter";
import { handleDateMentions, clearDateMentionConversions } from "../convertNotif";
import { injectFonts, setCurrentFont } from "../fontInjection";
import { LOG_PREFIX, MESSAGE_TYPES, DEBOUNCE_DELAY, STORAGE_KEYS, SELECTOR_DATE_BUTTONS, SELECTOR_PREV_MONTH, SELECTOR_NEXT_MONTH, SELECTOR_DATE_FORMAT_CLEAR, SELECTOR_DATE_MENTION, SELECTOR_PROPERTY_VALUE, SELECTOR_DATE_PICKER_INPUT, TIME_THRESHOLD_MS } from "../constant";
import "../convertCalendar";
import "../convertPageCalendar";
import "../convertTimeline";

let persianInput = false;
let fontInjectionEnabled = false;
let isProcessingDateConversion = false;
let debounceTimer: number | null = null;

chrome.storage.sync.get([STORAGE_KEYS.PERSIAN_INPUT, STORAGE_KEYS.FONT_INJECTION_ENABLED], d => {
    console.log(`${LOG_PREFIX} Initial state loaded`, d);
    persianInput = !!d[STORAGE_KEYS.PERSIAN_INPUT];
    fontInjectionEnabled = !!d[STORAGE_KEYS.FONT_INJECTION_ENABLED];

    if (persianInput) setTimeout(() => processDates(), 500);
    injectFonts(fontInjectionEnabled);
});

chrome.runtime.onMessage.addListener(async (msg, sender, sendResponse) => {
    if (msg.type === MESSAGE_TYPES.APPLY_SETTINGS && msg.data) {
        persianInput = !!msg.data[STORAGE_KEYS.PERSIAN_INPUT];
        fontInjectionEnabled = !!msg.data[STORAGE_KEYS.FONT_INJECTION_ENABLED];
        if (msg.data[STORAGE_KEYS.SELECTED_FONT]) setCurrentFont(msg.data[STORAGE_KEYS.SELECTED_FONT]);
        injectFonts(fontInjectionEnabled);
        if (persianInput) await processDates();
        return;
    }

    console.log(`${LOG_PREFIX} Received message`, msg);

    if (msg.persianInput !== undefined) {
        persianInput = msg.persianInput;
        console.log(`${LOG_PREFIX} Persian input set to`, persianInput);
        await processDates();
    }

    if (msg.fontInjectionEnabled !== undefined) {
        fontInjectionEnabled = msg.fontInjectionEnabled;
        console.log(`${LOG_PREFIX} Font injection set to`, fontInjectionEnabled);
        injectFonts(fontInjectionEnabled);
    }

    if (msg.selectedFont) {
        console.log(`${LOG_PREFIX} Font selection changed to`, msg.selectedFont);
        setCurrentFont(msg.selectedFont);
    }

    if (msg[MESSAGE_TYPES.CHECK_ERRORS]) {
        const errorCount = getErrorCount();
        console.log(`${LOG_PREFIX} Returning error count`, errorCount);
        sendResponse({ errorCount });
        return true;
    }

    if (msg[MESSAGE_TYPES.REFRESH_CONVERSION]) {
        console.log(`${LOG_PREFIX} Reset requested`);
        const resetCount = await resetAllConversions();
        const resetMentionCount = clearDateMentionConversions();
        const totalResetCount = resetCount + resetMentionCount;

        if (msg.forceReload) {
            chrome.runtime.sendMessage({ [MESSAGE_TYPES.RESET_COMPLETE]: true, count: totalResetCount, reloading: true });
            window.location.reload();
            return true;
        }

        setTimeout(async () => {
            if (persianInput) await processDates();
            chrome.runtime.sendMessage({ [MESSAGE_TYPES.RESET_COMPLETE]: true, count: totalResetCount });
        }, 500);
        return true;
    }

    return false;
});

async function processDates() {
    if (isProcessingDateConversion) {
        console.log(`${LOG_PREFIX} Already processing, skipping`);
        return;
    }

    isProcessingDateConversion = true;

    try {
        console.log(`${LOG_PREFIX} Processing dates, mode:`, persianInput ? "Persian" : "Gregorian");
        const tableCount = await convertTableDates(persianInput);
        const mentionCount = handleDateMentions(persianInput);
        const totalCount = tableCount + mentionCount;

        const errorCount = getErrorCount();
        if (errorCount > 0) {
            chrome.runtime.sendMessage({ [MESSAGE_TYPES.ERROR_COUNT_CHANGED]: true, errorCount });
        }

        console.log(`${LOG_PREFIX} Processed ${totalCount} dates (${tableCount} table dates, ${mentionCount} mentions)`);
    } finally {
        isProcessingDateConversion = false;
    }
}

function setupEventListeners() {
    document.addEventListener("click", (e) => {
        if (!persianInput) return;
        const target = e.target as HTMLElement;
        if (
            target.matches(SELECTOR_DATE_BUTTONS) ||
            target.closest(SELECTOR_PREV_MONTH) ||
            target.closest(SELECTOR_NEXT_MONTH) ||
            (target.closest(SELECTOR_DATE_FORMAT_CLEAR) && (target.textContent?.includes("Date format") || target.textContent?.includes("Clear")))
        ) {
            console.log(`${LOG_PREFIX} Date picker interaction detected`);
            setTimeout(() => processDates(), DEBOUNCE_DELAY);
        }

        if (target.closest(SELECTOR_DATE_MENTION) && (target.textContent?.includes('@Date') || target.textContent?.includes('@Reminder'))) {
            console.log(`${LOG_PREFIX} Date mention interaction detected`);
            setTimeout(() => processDates(), 800);
        }
    });

    document.addEventListener("input", (e) => {
        if (!persianInput) return;
        const target = e.target as HTMLElement;
        if (target.closest(SELECTOR_PROPERTY_VALUE) || (target.tagName === "INPUT" && target.closest(SELECTOR_DATE_PICKER_INPUT))) {
            console.log(`${LOG_PREFIX} Date field input detected`);
            if (debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = window.setTimeout(() => processDates(), DEBOUNCE_DELAY);
        }
    });
}

function setupMutationObserver() {
    const observer = new MutationObserver((mutations) => {
        if (!persianInput || isDateConversionInProgress() || wasDateConversionRecent(TIME_THRESHOLD_MS)) return;

        const hasDateChanges = mutations.some(mutation => {
            if (mutation.type === 'characterData' && mutation.target.nodeType === Node.TEXT_NODE && mutation.target.textContent) return true;
            if (mutation.type === 'childList' && mutation.target instanceof HTMLElement &&
                (mutation.target.closest(SELECTOR_PROPERTY_VALUE) || mutation.target.closest(".notion-date") ||
                    mutation.target.closest(".notion-reminder") || mutation.target.closest(SELECTOR_DATE_PICKER_INPUT))) return true;
            return false;
        });

        if (hasDateChanges) {
            console.log(`${LOG_PREFIX} Date changes detected by observer`);
            if (debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = window.setTimeout(() => processDates(), DEBOUNCE_DELAY);
        }
    });

    observer.observe(document.body, { childList: true, subtree: true, characterData: true });
}

function setupErrorReporting() {
    setInterval(() => {
        if (!persianInput) return;
        const errorCount = getErrorCount();
        if (errorCount > 0) {
            chrome.runtime.sendMessage({ [MESSAGE_TYPES.ERROR_COUNT_CHANGED]: true, errorCount }, () => { });
        }
    }, 5000);
}

setupEventListeners();
setupMutationObserver();
setupErrorReporting();

+++++
